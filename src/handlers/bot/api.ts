import { TOrder } from '@/helpers/types'
import axios from 'axios'
import env from '@/helpers/env'
import fs from 'fs'
import path from 'path'
// Add 'http://' to the URL
const BASE_URL_SEND_MESSAGE = `https://7103.api.greenapi.com/waInstance${env.INSTANCE_ID}/sendMessage/${env.TOKEN}`
const BASE_URL_SEND_FILE = `https://7103.api.greenapi.com/waInstance${env.INSTANCE_ID}/sendFileByUrl/${env.TOKEN}`
const BASE_URL_LAST_INCOMING_MESSAGES = `https://7103.api.greenapi.com/waInstance${env.INSTANCE_ID}/lastIncomingMessages/${env.TOKEN}`

export const fetchLastIncomingMessages = async (minutes = 5) => {
  try {
    const response = await axios.get(BASE_URL_LAST_INCOMING_MESSAGES, {
      params: { minutes },
    })
    return response.data
  } catch (error) {
    console.error('Error fetching last incoming messages:', error)
    throw error
  }
}

export const sendMessageToSpecialists = async (orderDetails: TOrder) => {
  try {
    const payload = {
      chatId: env.CHAT_ID_TEST,
      message: formatOrderMessage(orderDetails),
    }

    // Check if photoURL exists in orderDetails
    if (orderDetails.options.photoURL) {
      const filePayload = {
        chatId: env.CHAT_ID_TEST,
        urlFile: orderDetails.options.photoURL,
        fileName: '–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ', // You can customize this as needed
        caption: formatOrderMessage(orderDetails), // You can customize this as needed
      }
      const response = await axios.post(BASE_URL_SEND_FILE, filePayload, {
        headers: {
          'Content-Type': 'application/json',
        },
      })
      return response.data
    }

    const response = await axios.post(BASE_URL_SEND_MESSAGE, payload)
    return response.data
  } catch (error) {
    console.error('Error creating order:', error)
    throw error
  }
}

export const sendSpecialistAlredyFindedMessageToUser = async (
  time: number,
  number: string
) => {
  try {
    console.log(333)
    const userChatID = number + '@c.us'
    const arrivalTime = time + 10
    const payload = {
      chatId: userChatID,
      message: `–°–ø–µ—Ü–∏–∞–ª–∏—Å—Ç –Ω–∞–π–¥–µ–Ω! –û–Ω –±—É–¥–µ—Ç —É –≤–∞—Å —á–µ—Ä–µ–∑ ${arrivalTime} –º–∏–Ω—É—Ç`,
    }

    const response = await axios.post(BASE_URL_SEND_MESSAGE, payload)
    console.log(111)
    console.log(response)
    return response.data
  } catch (error) {
    console.error('Error creating order:', error)
    throw error
  }
}

export const sendConfirmationMessageToUser = async (
  orderDetails: TOrder,
  number: string
) => {
  try {
    const userChatID = number + '@c.us'
    const payload = {
      chatId: userChatID,
      message: formatConfirmationMessage(orderDetails),
    }

    const response = await axios.post(BASE_URL_SEND_MESSAGE, payload)
    return response.data
  } catch (error) {
    console.error('Error creating order:', error)
    throw error
  }
}

export const sendVerificationCode = async (phoneNumber: string) => {
  try {
    const code = Math.floor(10000 + Math.random() * 90000).toString()
    const payload = {
      chatId: `${phoneNumber}@c.us`,
      message: `ukol.kz –∫–æ–¥: *${code}*`,
    }
    const response = await axios.post(BASE_URL_SEND_MESSAGE, payload)
    return {
      data: response.data,
      code: code,
    }
  } catch (error) {
    console.error('Error sending verifucation code:', error)
    throw error
  }
}

function formatOrderMessage(orderDetails: TOrder): string {
  // Extracting necessary fields
  const { title, address, amount, options, arrivalTime } = orderDetails

  // Prepare options list, filtering out falsy values and formatting the output
  const optionsList = Object.entries(options)
    .filter(([, value]) => value) // Keep only options with truthy values
    .map(([key]) => {
      // Replace keys with user-friendly strings
      switch (key) {
        case 'isNeedPharmacy':
          return '‚Ä¢ –ù—É–∂–Ω–æ –∑–∞–π—Ç–∏ –≤ –∞–ø—Ç–µ–∫—É'
        case 'isHaveDoctorsAppointment':
          return '‚Ä¢ –ï—Å—Ç—å –Ω–∞–∑–Ω–∞—á–µ–Ω–∏–µ –≤—Ä–∞—á–∞'
        case 'isWithDrugsCocktail':
          return '‚Ä¢ –ù—É–∂–Ω—ã –ø—Ä–µ–ø–∞—Ä–∞—Ç—ã –¥–ª—è –∫–æ–∫—Ç–µ–π–ª—è'
        case 'isPremiumIntoxication':
          return '‚Ä¢ –ü—Ä–µ–º–∏—É–º –∏–Ω—Ç–æ–∫—Å–∏–∫–∞—Ü–∏—è'
        case 'isWithDressingMaterial':
          return '‚Ä¢ –° –ø–µ—Ä–µ–≤—è–∑–æ—á–Ω—ã–º –º–∞—Ç–µ—Ä–∏–∞–ª–æ–º'
        case 'isWithMaterialsPoisoning':
          return '‚Ä¢ –° –ø—Ä–µ–ø–∞—Ä–∞—Ç–∞–º–∏'
        default:
          return ''
      }
    })
    .join('\n')

  // Determine arrival time message
  const arrivalTimeMessage =
    arrivalTime && arrivalTime.isNearestHour
      ? '*–ù–∞ –≤—Ä–µ–º—è:* –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è'
      : `*–ù–∞ –≤—Ä–µ–º—è:* ${arrivalTime?.hours || 'N/A'} —á–∞—Å–æ–≤ ${
          arrivalTime?.minutes || 'N/A'
        } –º–∏–Ω—É—Ç—ã`

  // Construct the message
  const LINK_TO_YANDEX_MAP = `https://yandex.ru/maps/?ll=${orderDetails.lng},${orderDetails.lat}&z=18&l=map&pt=${orderDetails.lng},${orderDetails.lat}`
  return (
    `üì¢ *–ó–∞–∫–∞–∑*\n\n` +
    `*–£—Å–ª—É–≥–∞:* ${title || 'N/A'}\n` +
    `*–ê–¥—Ä–µ—Å:* ${address || 'N/A'}\n` +
    `*–Ø–Ω–¥–µ–∫—Å –ö–∞—Ä—Ç—ã:* ${LINK_TO_YANDEX_MAP}\n` +
    `*–ò—Ç–æ–≥ –∫ –æ–ø–ª–∞—Ç–µ:* ${amount || 0}‚Ç∏\n` +
    `*–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —É—Å–ª—É–≥–∏:*\n${optionsList || '–ù–µ –≤—ã–±—Ä–∞–Ω—ã'}\n` +
    `${arrivalTimeMessage}\n`
  )
}

const BASE_URL_UPLOAD = `https://7103.api.greenapi.com/waInstance${env.INSTANCE_ID}/uploadFile/${env.TOKEN}`

export const uploadeAppointmentPhoto = async (file: any) => {
  const filePath = path.join(__dirname, './../../../uploads', file.originalname) // Adjust the path as necessary
  const fileBuffer = fs.readFileSync(filePath) // Read the file into a buffer

  try {
    const response = await axios.post(BASE_URL_UPLOAD, fileBuffer, {
      headers: {
        'Content-Type': file.mimetype, // Set the correct content type
      },
    })

    console.log(response.data)
    return response.data
  } catch (error) {
    console.error('Error uploading file:', error)
    throw error
  }
}

function formatConfirmationMessage(orderDetails: TOrder): string {
  // Extracting necessary fields
  const { title, address, amount, options, arrivalTime } = orderDetails

  // Prepare options list, filtering out falsy values and formatting the output
  const optionsList = Object.entries(options)
    .filter(([, value]) => value) // Keep only options with truthy values
    .map(([key]) => {
      // Replace keys with user-friendly strings
      switch (key) {
        case 'isNeedPharmacy':
          return '‚Ä¢ –ù—É–∂–Ω–æ –∑–∞–π—Ç–∏ –≤ –∞–ø—Ç–µ–∫—É'
        case 'isHaveDoctorsAppointment':
          return '‚Ä¢ –ï—Å—Ç—å –Ω–∞–∑–Ω–∞—á–µ–Ω–∏–µ –≤—Ä–∞—á–∞'
        case 'isWithDrugsCocktail':
          return '‚Ä¢ –ù—É–∂–Ω—ã –ø—Ä–µ–ø–∞—Ä–∞—Ç—ã –¥–ª—è –∫–æ–∫—Ç–µ–π–ª—è'
        case 'isPremiumIntoxication':
          return '‚Ä¢ –ü—Ä–µ–º–∏—É–º –∏–Ω—Ç–æ–∫—Å–∏–∫–∞—Ü–∏—è'
        case 'isWithDressingMaterial':
          return '‚Ä¢ –° –ø–µ—Ä–µ–≤—è–∑–æ—á–Ω—ã–º –º–∞—Ç–µ—Ä–∏–∞–ª–æ–º'
        case 'isWithMaterialsPoisoning':
          return '‚Ä¢ –° –ø—Ä–µ–ø–∞—Ä–∞—Ç–∞–º–∏'
        default:
          return ''
      }
    })
    .join('\n')

  // Determine arrival time message
  const arrivalTimeMessage =
    arrivalTime && arrivalTime.isNearestHour
      ? '*–ù–∞ –≤—Ä–µ–º—è:* –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è'
      : `*–ù–∞ –≤—Ä–µ–º—è:* ${arrivalTime?.hours || 'N/A'} —á–∞—Å–æ–≤ ${
          arrivalTime?.minutes || 'N/A'
        } –º–∏–Ω—É—Ç—ã`

  // Construct the message
  return (
    `‚úÖ*–í–∞—à –∑–∞–∫–∞–∑ —É—Å–ø–µ—à–Ω–æ –ø–æ–ª—É—á–µ–Ω*‚úÖ\n\n` +
    `–ú—ã –æ–ø–æ–≤–µ—Å—Ç–∏–º –≤–∞—Å –æ —Ç–æ–º –∫–æ–≥–¥–∞ –ø–æ–¥–±–µ—Ä–µ–º –≤–∞–º –ø–æ–¥—Ö–æ–¥—è—â—É—é –º–µ–¥—Å–µ—Ç—Å—Ä—É –∏ —á–µ—Ä–µ–∑ —Å–∫–æ–ª—å–∫–æ –æ–Ω–∞ –ø—Ä–∏–µ–¥–µ—Ç\n\n` +
    `*–î–µ—Ç–∞–ª–∏ –∑–∞–∫–∞–∑–∞:*\n` +
    `*–£—Å–ª—É–≥–∞:* ${title || 'N/A'}\n` +
    `*–ê–¥—Ä–µ—Å:* ${address || 'N/A'}\n` +
    `*–ò—Ç–æ–≥ –∫ –æ–ø–ª–∞—Ç–µ:* ${amount || 0}‚Ç∏\n` +
    `*–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —É—Å–ª—É–≥–∏:*\n${optionsList || '–ù–µ –≤—ã–±—Ä–∞–Ω—ã'}\n` +
    `${arrivalTimeMessage}\n`
  )
}
